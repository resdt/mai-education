\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{pgfplots}
\usepackage{enumitem}
\usepackage{verbatim}


\begin{document}

\section*{Лабораторная работа №\,4 по курсу дискрeтного анализа: Строковые алгоритмы}
Выполнил студент группы М80-208Б-22 \textit{Ширяев Никита}.

\subsection*{Условие}

Необходимо реализовать поиск одного образца в тексте с использованием алгоритма Z-блоков. Алфавит — строчные латинские буквы. 

\subsection*{Метод решения}

Программа использует алгоритм вычисления Z-функции для строки с разделителем, чтобы найти все вхождения заданного образца (подстроки) в строке. В данном случае программа ищет в строке, полученной путем объединения искомого образца и входной строки с использованием специального символа-разделителя \texttt{\$}.

Разделитель выбирается таким образом, чтобы не принадлежать алфавиту исходного образца, чтобы избежать неправильного сопоставления вхождений образца с другими частями строки.

Алгоритм вычисления Z-функции позволяет эффективно определить длину наибольшего общего префикса (подстроки, начинающейся с первого символа строки) между текущей позицией и всеми возможными суффиксами строки. Значения Z-функции, равные длине образца, указывают на точные вхождения образца в строку.

В итоге программа выводит позиции, соответствующие точным вхождениям образца в строку, на основе вычисленных значений Z-функции.

\subsection*{Описание программы}
\begin{itemize}
\item Функция \texttt{computeZArray} вычисляет Z-функцию для входной строки. Значение Z[i] соответствует длине наибольшей подстроки, начинающейся с позиции i, которая также является префиксом всей строки.

\item Функция \texttt{findPatternInText} строит новую строку, конкатенируя шаблон, специальный символ и исходный текст, и вычисляет Z-функцию для этой строки. Затем она просматривает полученный массив и выводит позиции, где Z[i] равно размеру шаблона, указывая на вхождения шаблона в исходном тексте.

\item Функция \texttt{main} является точкой входа в программу. Она считывает текст и шаблон из стандартного ввода и вызывает функцию \texttt{findPatternInText}, чтобы найти все вхождения шаблона в текст.
\end{itemize}


\subsection*{Тест производительности}
\begin{tikzpicture}
\begin{axis}[
    title={Сравнение сложности алгоритмов поиска},
    xlabel={Размер строки},
    ylabel={Время выполнения (сек)},
    xmin=1e5, xmax=8e5,
    ymin=0, ymax=15,
    xtick={1e5,2e5,3e5,4e5,5e5,6e5,7e5,8e5},
    xticklabels={1e5,2e5,3e5,4e5,5e5,6e5,7e5,8e5},
    ytick={0,3,6,9,12,15},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
]

\addplot[
    color=blue,
    mark=square,
] 
    coordinates {(1e5,0)(2e5,2)(4e5,4)(6e5,6)(8e5,8)};
    \addlegendentry{Z-функция}

\addplot[
    color=red,
    mark=triangle,
]
    coordinates {(1e5,0)(2e5,4)(4e5,8)(6e5,12)(8e5,15)};
    \addlegendentry{Наивный поиск}
    
\end{axis}
\end{tikzpicture}

\subsection*{Выводы}

Алгоритм Z-функции показал высокую эффективность по сравнению с наивным алгоритмом поиска. Из графика видно, что время выполнения алгоритма Z-функции остается стабильным и низким при увеличении размера входных данных. Это делает его привлекательным для использования в реальных приложениях, где размер входных данных может быть большим.

Наивный алгоритм поиска, несмотря на его простоту, не подходит для больших входных данных из-за его высокой сложности. Этот факт подтверждается на графике, где время выполнения наивного алгоритма увеличивается по мере роста размера входных данных.


\end{document}


