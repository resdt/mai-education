\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{pgfplots}
\usepackage[russian]{babel}

\begin{document}

\section*{Лабораторная работа №\,1 по курсу дискрeтного анализа: сортировка за линейное время}

Выполнил студент группы М8О-208Б-22 МАИ \textit{Ширяев Никита}.

\subsection*{Условие}

\textbf{Задача:}
Требуется разработать программу, осуществляющую ввод пар «ключ-значение», их упорядочивание по возрастанию ключа указанным алгоритмом сортировки за линейное время и вывод отсортированной последовательности.\newline
\newline
\textbf{Вариант:}
\begin{itemize}
    \item H.3-2
    \item Поразрядная сортировка
    \item Тип ключа: число от 0 до $2^{64} - 1$
    \item Тип значения: строки переменной длины (до 2048 символов)
\end{itemize}


\subsection*{Метод решения}

Для выполнения данного задания была реализована поразрядная сортровка. В данном случае был использован  метод сортировки наименьшего значащего разряда (LSD - Least Significant Digit). Он работает путем сортировки чисел по их битовым представлениям, начиная с младших разрядов и постепенно перемещаясь к старшим.
Основная идея алгоритма заключается в том, чтобы разделить числа на бакеты в соответствии с их разрядами и для каждого бакета применить устойчивую сортировку подсчетомю Элементы из бакетов распределяются в буфер в соответствии с их позицией в порядке сортировки и исходный массив переупорядочивается в соответствии с буфером.

\subsection*{Описание программы}

Входные данные представляют собой пару $"$ключ-значение$"$ , которые хранятся в структуре TPair. Тип данных для ключа uint\_t64 позволит хранить любой ключ вплоть до  $2^{64} - 1$ символов. Значением ключа является строка перменной длины для её хранения был создан класс TStr, содержащий информацию о размере строки и массив элементов типа char. В данном классе реализованы функции:
\begin{itemize}
    \item TStr() - конструктор
    \item TStr(const char* str) - конструктор с заданием элемента
    \item TStr(const TStr& other) - конструктор копирования
    \item TStr& operator=(const TStr& other) - оператор присваивания
    \item friend std::ostream& operator<<(std::ostream& os, const TStr& str) - перегрузка оператора вывода
    \item ~TStr() - деструктор класса
\end{itemize}

Для хранения пар был создан класс TVector, содержащий информацию о размере, ёмкости и данных объекта. В нем реализованы функции:
\begin{itemize}
    \item TVector() - конструктор по умолчанию, создающий пустой вектор
    \item TVector(length\_t newSize) - конструктор, создающий вектор заданного размера
    \item TVector(const TVector\& other) - конструктор копирования
    \item \textasciitilde TVector() - деструктор класса
    \item \length\_t Size() const - возвращает текущий размер вектора.
    \item void PushBack(const T\& value) - добавляет элемент в конец вектора
    \item void Assign(length\_t\& newSize, T value) - заменяет содержимое вектора новыми данными указанного размера.
    \item const T\& operator[](length\_t index) const - иозвращает константную ссылку на элемент вектора по указанному индексу
    \item T\& operator[](length\_t index) - возвращает ссылку на элемент вектора по указанному индексу
    \item T* begin() - возвращает указатель на первый элемент вектора
    \item T* end() - возвращает указатель на элемент, следующий за последним элементом вектора
    \item const T* begin() const - возвращает константный указатель на первый элемент вектора.
    \item const T* end() const - возвращает константный указатель на элемент, следующий за последним элементом вектора
    \item void Relength(length\_t\& newCapacity) - изменяет размер внутренней ёмкости вектора.
\end{itemize}

Для каждой пары в векторе применяется поразрядная сортировка по ключу.

\subsection*{Дневник отладки}

В начале не был учтен заверщающий нулевой символ при выборе максимального размера строки, из-за чего происходило переполнение буфера.\newline
Далее производились попытки оптимизировать сортировку. Уменьшалось количество битов для вычисления разрядов, чтобы производить сортировку на меньшем количестве групп. Производился поиск максимального значения ключа, что позволяет определить диапазон значений ключей, которые могут присутствовать в массиве.\newline
В конечном итоге вернулись к начальному варианту сортировки, но был создан отдельный вектор для хранения строк-значений ключей, а в пару к ключу записывался индекс этой строки типа length\_t, что позволило уменьшить объем данных, который нужно сортировать и перемещать.

\subsection*{Тест производительности}

Для измерения производительсти сравнивается время выполнения реализованной поразрядной сортировки и сортировки std::stable\_sort на одинаковых входных данных. Подсчет времени производился с помощью библиотеки chrono, которая позволяет фиксировать время в начале и конце выполнения сортировки. Первыйтест состоит из $10^6$ пар клбч-значения, второй из $2 * 10^6$ пар, третий из $4 *10^6$, четвертый из $6 * 10^6$, пятый из $8 * 10^6$ и шестой из $10^7$ пар.
\newline

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}
        \begin{axis}[
            xlabel={Объём входных данных ($\times 10^6$)},
            ylabel={Время работы (ms)},
            grid=major,
            xmin=0, xmax=1,
            ymin=0, ymax=2.5,
            xtick={0,0.2,0.4,0.6,0.8,1},
            ytick={0,0.5,1,1.5,2,2.5},
            legend style={at={(0.5,-0.2)},anchor=north},
            legend columns=2,
            width=0.8\textwidth,
            height=0.5\textwidth,
            ]
            \addplot[color=blue,mark=*] coordinates {
                (0,0)
                (0.1,0.16)
                (0.2,0.311)
                (0.4,0.606)
                (0.6,0.923)
                (0.8,1.214)
                (1,1.534)
            };
            \addlegendentry{RadixSort}
            \addplot[color=red,mark=square] coordinates {
                (0,0)
                (0.1,0.186)
                (0.2,0.391)
                (0.4,0.819)
                (0.6,1.251)
                (0.8,1.772)
                (1,2.161)
            };
            \addlegendentry{std::stable\_sort}
        \end{axis}
    \end{tikzpicture}
    \label{fig:graph}
\end{figure}

На графике представлена зависимость времени выполнения сортировки от объёма входных данных. Сложность поразрядной сортировки $O(n * k)$, где n - количество элементов массива, k - число разрядов ключа. Сложность stable\_sort $O(n*log(n))$.

\subsection*{Выводы}

В ходе данной лабораторной работы была изучена реализация классов STL, разобрана поразрядная сортировка за линейное время. Было выяснено, что данная сортировка работает наиболее эффективно именно с большим объёмом данных. Также были освоены отладка утечек памяти и оптимизация алгоритма сортировки. Полученные результаты подчеркивают важность выбора правильного алгоритма сортировки в зависимости от объема данных для достижения оптимальной производительности.

\end{document}